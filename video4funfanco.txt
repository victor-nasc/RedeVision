
'''
Combining YOLO with Visual Rhythm for Vehicle Counting  

Usage:
    python count.py [options]    
    --line: line position                           [defalt:  600]
    --interval: interval between VR images (frames) [default: 900]
    --save-VR: enable saving VR images              [default: False]
    --save-vehicle: enable saving vehicle images    [default: False]
    
    The video path is asked in the execution.
    
    The results are printed in the terminal 
    and saved detaily in 'infos.txt' and.
'''

# video_path = 'videoplayback2.mp4'
# 1977 perde um carro na msm mancha que um caminhao



# TESTAR EM OUTROS VIDEOS + DEFINIR LINHA


import cv2
import numpy as np
from ultralytics import YOLO

import argparse
import os

# 450
aa = 370
bb = 1200

# 300
# aa = 180 
# bb = 830
def counting(line, frame, l, r, time, model_vehicle, saveVehicle, midlane):
    labels = ['Bus', 'Car', 'Motorbike', 'Pickup', 'Truck', 'Van', '???'] 
    delta = 90
    count = np.array([0, 0, 0, 0, 0, 0, 0])
    infos = []
    height , width, _ = np.shape(frame)


    # detect vehicles
    vehicles = model_vehicle(frame, iou=0.5, conf=0.3, verbose=False, save=True, agnostic_nms=True)
    vehicles = vehicles[0].numpy()
    
    
    # extend the mark's x-coordinates
    l = max(l - delta, 0) + aa
    r = min(r + delta, width) + aa
    
    
    # find the vehicle associated with the mark
    dist_min = height
    crop = frame
    classe = conf = -1
    for cls, xyxy, cnf in zip(vehicles.boxes.cls.astype(int), vehicles.boxes.xyxy, vehicles.boxes.conf):
        x0, y0, x1, y1 = np.floor(xyxy).astype(int)
        mid_x = (x0 + x1) // 2
        mid_lr = (l + r) // 2
        y = y0 if mid_x < midlane else y1
        print(y0, y1, y,'-', mid_x, x0, x1, l, r, '-', x0 > l, x1 < r, abs(y-line) < 90)
        if x0 > l and x1 < r and abs(y-line) < 90:
            count[cls] += 1
            infos.append([labels[classe], frame, conf, x0, y0, x1, y1])
            print('oi')
            # dist = abs(y0 - line)
            # if dist < dist_min:
            #     dist_min = dist
            #     classe = int(cls)
            #     conf = cnf
            if saveVehicle:
                crop = frame[y0:y1 , x0:x1]
    

    if np.sum(count) == 0:
        print(f"Couldn't find the vehicle in frame {time}!!!")
        print('VERIFY IT MANUALLY')


    if saveVehicle:
        name = f'vehicle-crops/{str(labels[classe])}{time}.jpg'
        print(f'Saving as {name}')
        cv2.imwrite(name, crop)
        
        
    # update infos
    for i in range(len(count)):
        if count[i] > 0:
            print(f'{count[i]} {labels[i]} detected in frame {time}\n')

    # print(f'{labels[classe]} detected with confidence {conf:.2f} \n')

    cv2.waitKey(0)
    return count, infos
        
        
        
def count_clusters(vector):
    count = []
    in_cluster = False

    for i in range(np.size(vector)):
        if vector[i] == 255:
            if not in_cluster:
                ini = i
                in_cluster = True
        else:
            if in_cluster == True:
                count.append(ini)
                count.append(i-1)
            in_cluster = False
            
    return count




def main(video_path, line, sec, saveVR, saveVehicle, midlane):
    ini = 0     # current VR initial frame
    double = [] # marks on the border of the previous VR
    infos = [['label', 'frame', 'conf', 'x0', 'y0', 'x1', 'y1']]  # details of each vehicle
    VR = []     # VR image
    count = np.array([0, 0, 0, 0, 0, 0, 0]) # count of each class
    time = 0
    
    VR_or = []
    VR = []
    
    # load models
    model_mark = YOLO('./YOLO/marks/weights/best.pt')
    model_vehicle = YOLO('./YOLO/vehicle/weights/best.pt')


    # opens the video
    cap = cv2.VideoCapture(video_path)
    assert cap.isOpened() == True, 'Can not open the video'


    # creates folders to save images
    if saveVehicle and not os.path.exists('vehicle-crops/'):
        os.makedirs('vehicle-crops/')
    if saveVR and not os.path.exists('VR-images/'):
        os.makedirs('VR-images/')
        
        
        
        
    # move to frame 1000
    cap.set(cv2.CAP_PROP_POS_FRAMES, 1500+5700)
    
    
    
    
    ret , ini = cap.read()
    if not ret:
        print('Error reading video')
        return
    
    _ , width, _ = np.shape(ini)
    
    ini = cv2.cvtColor(ini, cv2.COLOR_BGR2GRAY)
    ini = ini[line, aa:bb+1]
    linha_or = np.zeros((bb-aa+1, 1))
    
    # begins video 
    while True: 
        ret, frameRGB = cap.read() 
        if not ret:
            print('Error reading video')
            break
        
        frame = cv2.cvtColor(frameRGB, cv2.COLOR_BGR2GRAY)
        linhaORI = frame[line, aa:bb+1]  

        linha = cv2.absdiff(ini,linhaORI)
        linha = cv2.blur(np.array(linha), (1,5), 0)
        _, linha = cv2.threshold(linha, 12, 255, cv2.THRESH_BINARY)
        
        # stacks line in VR image
        linha[-1] = 0
        VR.append(linha)
        
        linha_or = np.logical_or(linha_or, linha//255).astype(int)
        
        counts = count_clusters(linha_or.astype(int)*255)
        # print(np.sum(linha)/255, np.size(counts))
        if(np.size(counts) > 0):
            for i in range(np.size(counts)//2):
                l = counts[2*i]
                r = counts[2*i + 1]
                intersec = np.logical_xor(linha[l:r+1]//255, linha_or[l:r+1])
                if r-l+1 < 20: 
                    linha_or[l:r+1] = 0
                elif(np.sum(intersec) == (r-l+1)):
                    print(l, r, np.sum(intersec), r-l+1)
                    cnt, inf = counting(line, frameRGB, l, r, time, model_vehicle, saveVehicle, midlane)
                    
                    count += cnt
                    infos += inf
                    
                    linha_or[l:r+1] = 0    


        VR_or.append(linha_or*255)

        cv2.line(frameRGB, (aa, line), (bb, line), (0, 255, 0), 2)
        cv2.imshow('frame', cv2.resize(frameRGB, (888, 500)))

        counts = []
        ini = linhaORI
        
        time += 1
        
        key = cv2.waitKey(1)
        if key == ord('q'):
            break
        
        continue
        
        # if VR image has been fully built
        if len(VR) == sec:        
            print(f'VR image {ini//sec} created')    

            if saveVR:
                name = 'VR-images/VR' + str(ini//sec) + '.jpg'
                print(f'Saving as {name}')
                cv2.imwrite(name, np.array(VR)) 
            
            double, cnt, inf = counting(np.array(VR), line, cap, ini, double, model_mark, model_vehicle, saveVehicle)                
            count += cnt
            infos += inf

            VR = []
            ini += sec
            cap.set(cv2.CAP_PROP_POS_FRAMES, ini)

    cv2.imwrite('VR_or.jpg', np.array(VR_or))
    cv2.imwrite('VR.jpg', np.array(VR))
    
    # final results
    print('\n -------------------------- \n')
    print_count(count)
    print(sum(count), 'vehicles counted in total')
    
    # write infosq
    with open('infos.txt', 'w') as file:
        for item in infos:
            file.write(str(item) + '\n')


    # closes the video
    cap.release()
    cv2.destroyAllWindows()
    
    
      
      
def print_count(count):
    labels = ['Bus', 'Car', 'Motorbike', 'Pickup', 'Truck', 'Van', '???'] 
    max_length = max(len(label) for label in labels)

    for label, cnt in zip(labels, count):
        print(f'{label.ljust(max_length)} : {cnt}')
      
      
      
      
if __name__ == "__main__":    

    # parse arguments
    parser = argparse.ArgumentParser(description='Count the number of vehicles in a video')
    
    parser.add_argument('--line', type=int, default=450, help='Line position')
    parser.add_argument('--interval', type=int, default=900, help='Interval between VR images (frames)')
    parser.add_argument('--save-VR', type=bool, default=False, help='Enable saving VR images')
    parser.add_argument('--save-vehicle', type=bool, default=False, help='Enable saving vehicle images')
    args = parser.parse_args()


    # video_path = input('Enter the video path: ')
    video_path = 'videoplayback1.mp4'
    midlane = 0
    
    # 400 1200
    print('Counting vehicles in the video...\n')
    main(video_path, args.line, args.interval, args.save_VR, args.save_vehicle, midlane)
